import { writeFileSync, mkdirSync } from "fs";
import {
  quicktype,
  InputData,
  jsonInputForTargetLanguage,
} from "quicktype-core";
import path from "path";
import { type EndpointConfig } from "./types";
import { CONFIG } from "./config";

async function quicktypeJSON(
  data: unknown[],
  rootName: string
): Promise<string> {
  const jsonInput = jsonInputForTargetLanguage("typescript");
  await jsonInput.addSource({
    name: rootName,
    samples: data.map((sample) => JSON.stringify(sample)),
  });

  const inputData = new InputData();
  inputData.addInput(jsonInput);

  const { lines } = await quicktype({
    inputData,
    lang: "typescript",
    rendererOptions: {
      "just-types": "true",
      "runtime-typecheck": "false",
      "prefer-types": "true",
    },
    inferMaps: true,
    inferEnums: true,
    alphabetizeProperties: true,
  });

  return lines.join("\n");
}

async function generateTypesForEndpoint(config: EndpointConfig): Promise<void> {
  const { variations, outputPath, rootName } = config;

  try {
    const samples: unknown[] = [];

    for (const variation of variations) {
      const { url, headers = {}, cookies = {} } = variation;
      if (!url) {
        console.warn("Warning: URL is undefined for a variation");
        continue;
      }

      const cookieString = Object.entries(cookies)
        .map(([key, value]) => `${key}=${value}`)
        .join("; ");

      const response = await fetch(url, {
        headers: {
          ...headers,
          ...(cookieString && { Cookie: cookieString }),
        },
        credentials:
          Object.keys(cookies).length > 0 ? "include" : "same-origin",
      });

      if (!response.ok) {
        console.warn(`Warning: Failed to fetch ${url}: ${response.status}`);
        continue;
      }

      const data = await response.json();
      samples.push(data);
    }

    if (samples.length === 0) {
      throw new Error(`No successful responses for ${rootName}`);
    }

    const types = await quicktypeJSON(samples, rootName);

    const dirPath = path.dirname(outputPath);
    mkdirSync(dirPath, { recursive: true });

    const output = [
      "// Generated by rest-to-ts",
      `// Generated at ${new Date().toISOString()}`,
      "// Sources:",
      ...variations.map((v) => `// - ${v.url}`),
      "",
      types,
      "",
    ].join("\n");

    writeFileSync(outputPath, output);
    console.log(`✅ Types generated for ${rootName} at ${outputPath}`);
  } catch (error) {
    console.error(`❌ Error generating types for ${rootName}:`, error);
    throw error;
  }
}

function chunk<T>(array: T[], size: number): T[][] {
  return Array.from({ length: Math.ceil(array.length / size) }, (_, index) =>
    array.slice(index * size, index * size + size)
  );
}

async function generateAllTypes({
  config,
  chunkSize = 3,
}: {
  config: EndpointConfig[];
  chunkSize?: number;
}): Promise<void> {
  try {
    const chunks = chunk(config, chunkSize);

    for (const [index, currentChunk] of chunks.entries()) {
      console.log(`Processing chunk ${index + 1}/${chunks.length}...`);

      await Promise.all(
        currentChunk.map((endpoint) => generateTypesForEndpoint(endpoint))
      );
    }

    console.log("✅ All types generated successfully!");
  } catch (error) {
    console.error("❌ Error generating types:", error);
    process.exit(1);
  }
}

generateAllTypes({ config: CONFIG, chunkSize: 3 });
